#!/usr/bin/python3

"""
A script for generating test cases from an XML definition. At present, the test
cases for the Raspberry Pi images involve a large amount of duplication, but
with minor variances. For example, the tests for the Pi 2 don't include wifi,
the Pi 3A+ has no ethernet, Pi 4 devices have two HDMI ports to test, and so
on. This script generates the test cases from an XML definition that permits
easy configuration of which tests to include or exclude, duplication of tests,
and variable substitution at a template, test-case, or individual test level.

The script must be run with an XML definition; it will re-generate all the test
cases specified in the given definition, writing the output to the configured
directory.
"""

import os
import re
import sys
import argparse
from copy import deepcopy
from pathlib import Path
from xml.etree import ElementTree as et


class ut:
    """
    A trivial class to define the XML namespace used in the configuration file
    and the (expanded) names of all the tags specific to that namespace.
    """
    ns       = 'com.ubuntu.tests'
    config   = f'{{{ns}}}configuration'
    template = f'{{{ns}}}template'
    tests    = f'{{{ns}}}tests'
    test     = f'{{{ns}}}test'
    case     = f'{{{ns}}}case'
    define   = f'{{{ns}}}define'
    include  = f'{{{ns}}}include'
    var      = f'{{{ns}}}var'
    action   = f'{{{ns}}}action'
    expected = f'{{{ns}}}expected'


def main(args=None):
    if sys.version_info < (3, 6):
        raise SystemExit('This script requires Python 3.6 or later')

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        'config', type=argparse.FileType('r'), metavar='XML-FILE',
        help="The configuration file to generate test cases from")
    parser.add_argument(
        '-o', '--output', default='testcases/image/', type=Path, metavar='DIR',
        help="The output directory; default: %(default)s")
    parser.add_argument(
        '--action-tag', default='dt', metavar='TAG',
        help="The HTML tag to wrap <ut:action> content in; default: "
        "%(default)s")
    parser.add_argument(
        '--expected-tag', default='dd', metavar='TAG',
        help="The HTML tag to wrap <ut:expected> content in; default: "
        "%(default)s")

    ns = parser.parse_args(args)

    try:
        for filename, doc in TestConfiguration(
                ns.config,
                action_tag=ns.action_tag,
                expected_tag=ns.expected_tag):
            content = et.tostring(doc, encoding='unicode', method='html')
            # Hack off the outer elements as the result is effectively an
            # incomplete snippet of HTML. We can't do this with etree as
            # it makes the result invalid XML, so just fudge it with some
            # regexes
            content = re.sub(r'^\s*<(?:\w+:)?template[^>]*>', '', content)
            content = re.sub(r'</(?:\w+:)?template>\s*$', '', content)
            content = f"""\
<!-- Please do not edit this file directly; it was generated with the
     tools/test_case_gen script using the following configuration as input:
     {ns.config.name}
-->
""" + content
            with open(ns.output / filename, 'w', encoding='utf-8') as f:
                f.write(content)
    except:
        if int(os.environ.get('DEBUG', '0')):
            raise
        else:
            typ, value, tb = sys.exc_info()
            print(value, file=sys.stderr)
            sys.exit(1)


def substitute(doc, path, content):
    """
    Given *doc*, an :class:`~xml.etree.ElementTree.Element` and *path*, an
    `XPath`_ search string, the function finds all elements matching *path* and
    replaces them with the contents of *content*, another
    :class:`~xml.etree.ElementTree.Element` instance. The resulting document
    is returned (the original *doc* is not modified).

    *content* can also be a callable. In this case, for each element matching
    *path*, the *content* callable will be called with *doc* and the matching
    element. It must return a single :class:`~xml.etree.ElementTree.Element`
    containing the content to substitute.

    .. _XPath: https://docs.python.org/3/library/xml.etree.elementtree.html#elementtree-xpath

    .. note::

        Note that the *contents* elements themselves are *not* included in the
        substitution. Only the descendents (including text, child elements,
        etc.) of *contents* are substituted, and the substitution replaces the
        placeholder element located by *path* entirely.
    """
    doc = deepcopy(doc)
    parent_map = {
        elem: parent
        for parent in doc.iter()
        for elem in parent
    }
    if not callable(content):
        content_fun = lambda doc, elem: content
    else:
        content_fun = content
    for placeholder in doc.findall(path):
        content = content_fun(doc, placeholder)
        parent = parent_map[placeholder]
        parent_index = list(parent).index(placeholder)
        if content.text is not None:
            if parent_index == 0:
                if parent.text is None:
                    parent.text = content.text
                else:
                    parent.text += content.text
                last = parent
            else:
                prior = parent[parent_index - 1]
                if prior.tail is None:
                    prior.tail = content.text
                else:
                    prior.tail += content.text
                last = prior
        for elem in content:
            last = deepcopy(elem)
            parent.insert(parent_index, last)
            parent_index += 1
        if last is parent:
            if last.text is None:
                last.text = placeholder.tail
            else:
                last.text += placeholder.tail
        else:
            if last.tail is None:
                last.tail = placeholder.tail
            else:
                last.tail += placeholder.tail
        parent.remove(placeholder)
    return doc


class TestConfiguration:
    """
    Given *xml_file*, a file-like object containing a compatible XML
    configuration for this script, this object will act as an iterator which
    yields tuples of (filename, xml-document), where "xml-document" is the
    :class:`~xml.etree.ElementTree.Element` at the root of the generated test
    case document.
    """
    def __init__(self, xml_file, *, action_tag='dt', expected_tag='dd'):
        super().__init__()
        xml_config = et.fromstring(xml_file.read())
        if xml_config.tag != ut.config:
            raise ValueError(
                'Expected to find <ut:config> as the root element')
        self._template = xml_config.find(f'./{ut.template}')
        if self._template is None:
            raise ValueError(
                'Expected to find <ut:template> under the <ut:config> '
                'element')
        if self._template.find(f'.//{ut.tests}') is None:
            raise ValueError(
                '<ut:template> must include <ut:tests> somewhere within it')
        try:
            self._tests = {
                elem.attrib['id']: elem
                for elem in xml_config.findall(f'./{ut.test}')
            }
        except KeyError:
            raise ValueError(f'Missing "id" attribute in {ut.test}')
        else:
            if not self._tests:
                raise ValueError(
                    'Expected to find at least one <ut:test> under the '
                    '<ut:config> element')
        try:
            self._cases = {
                elem.attrib['id']: elem
                for elem in xml_config.findall(f'./{ut.case}')
            }
        except KeyError:
            raise ValueError('Missing "id" attribute in <ut:case>')
        else:
            if not self._cases:
                raise ValueError(
                    'Expected to find at least one <ut:case> under the '
                    '<ut:config> element')
        self._action_tag = str(action_tag)
        self._expected_tag = str(expected_tag)
        self._env = self._build_env(root=xml_config)

    def _build_env(self, *, root):
        try:
            return {
                elem.attrib['name']: elem
                for elem in root.findall(f'./{ut.define}')
            }
        except KeyError:
            raise ValueError('Missing "name" attribute in <ut:define>')

    def __iter__(self):
        for case_id, case in self._cases.items():
            try:
                yield case_id, self._render_case(case)
            except ValueError as exc:
                raise ValueError(f'In <ut:case id={case_id!r}>: {exc}')

    def _render_case(self, case):
        env = self._env.copy()
        env.update(self._build_env(root=case))
        render = lambda doc, elem: self._render_var(doc, elem, env)
        return substitute(
            substitute(self._template, f'.//{ut.var}', render),
            f'.//{ut.tests}', self._render_includes(case, env))

    def _render_includes(self, case, env):
        result = deepcopy(case)
        for define in result.findall(f'./{ut.define}'):
            result.remove(define)
        render = lambda doc, elem: self._render_include(doc, elem, env)
        return substitute(result, f'./{ut.include}', render)

    def _render_include(self, case, include, env):
        try:
            test_ref = include.attrib['ref']
        except KeyError:
            raise ValueError('Missing "ref" attribute in <ut:include>')
        try:
            test = self._tests[test_ref]
        except KeyError:
            raise ValueError(f'<ut:test id={test_ref!r}> not found')
        env = env.copy()
        env.update(self._build_env(root=include))
        result = deepcopy(test)
        result.find(f'./{ut.action}').tag = self._action_tag
        result.find(f'./{ut.expected}').tag = self._expected_tag
        render = lambda doc, elem: self._render_var(doc, elem, env)
        return substitute(result, f'.//{ut.var}', render)

    def _render_var(self, include, var, env):
        try:
            var_name = var.attrib['name']
        except KeyError:
            raise ValueError('Missing "name" attribute in <ut:var>')
        try:
            return env[var_name]
        except KeyError:
            raise ValueError(f'<ut:define name={var_name!r}> not found')


if __name__ == '__main__':
    main()
